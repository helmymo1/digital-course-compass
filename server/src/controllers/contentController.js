const Content = require('../models/Content');
const User = require('../models/User'); // Assuming User model for author/approver refs
const mongoose = require('mongoose'); // For ObjectId validation and other Mongoose utilities

// Helper function to handle errors
const handleError = (res, error, statusCode = 500) => {
  console.error(error);
  res.status(statusCode).json({ message: error.message || 'An unexpected error occurred.' });
};

// 1. Create Content
exports.createContent = async (req, res) => {
  try {
    const { title, body, contentType, tags, metaData } = req.body;
    const author = req.user.id; // Assuming req.user.id is available from auth middleware

    if (!title || !body) {
      return res.status(400).json({ message: 'Title and body are required.' });
    }

    const newContent = new Content({
      title,
      body,
      author,
      contentType: contentType || 'article',
      tags,
      metaData,
      // Slug will be auto-generated by pre-save hook
      // Version history will be initialized by pre-save hook
    });

    const savedContent = await newContent.save();
    res.status(201).json(savedContent);
  } catch (error) {
    if (error.code === 11000) { // Duplicate key error (likely for slug)
        return handleError(res, { message: "Content with this title already exists (or leads to a duplicate slug)." }, 409);
    }
    handleError(res, error);
  }
};

// 2. Get Content by ID (or Slug)
exports.getContentByIdOrSlug = async (req, res) => {
  try {
    const identifier = req.params.identifier;
    const query = mongoose.Types.ObjectId.isValid(identifier) ? { _id: identifier } : { slug: identifier };

    const content = await Content.findOne(query)
      .populate('author', 'name email')
      .populate('approver', 'name email')
      .populate('versionHistory.updatedBy', 'name email');

    if (!content) {
      return res.status(404).json({ message: 'Content not found.' });
    }
    res.status(200).json(content);
  } catch (error) {
    handleError(res, error);
  }
};

// 3. Update Content
exports.updateContent = async (req, res) => {
  try {
    const contentId = req.params.id;
    const updates = req.body; // { title, body, contentType, tags, metaData }
    const userId = req.user.id;

    const content = await Content.findById(contentId);
    if (!content) {
      return res.status(404).json({ message: 'Content not found.' });
    }

    // Versioning: Add current body to version history before updating if body changes
    if (updates.body && updates.body !== content.body) {
        content.versionHistory.push({
            body: content.body,
            version: content.version,
            updatedBy: userId, // User performing the update
            updatedAt: content.updatedAt
        });
        content.version += 1;
        content.body = updates.body;
    }

    // Update other fields
    if (updates.title) {
        content.title = updates.title;
        // Regenerate slug if title changes
        content.slug = updates.title.toLowerCase().replace(/\s+/g, '-').replace(/[^\w-]+/g, '');
    }
    if (updates.contentType) content.contentType = updates.contentType;
    if (updates.tags) content.tags = updates.tags;
    if (updates.metaData) content.metaData = { ...content.metaData, ...updates.metaData };

    content.updatedAt = Date.now();

    const updatedContent = await content.save();
    res.status(200).json(updatedContent);
  } catch (error) {
    if (error.code === 11000) {
        return handleError(res, { message: "Update failed due to a conflict (e.g., duplicate title/slug)." }, 409);
    }
    handleError(res, error);
  }
};

// 4. Delete Content (Soft Delete)
exports.deleteContent = async (req, res) => {
  try {
    const contentId = req.params.id;
    const content = await Content.findByIdAndUpdate(
        contentId,
        { status: 'archived', publishedAt: null, scheduledAt: null },
        { new: true }
    );

    if (!content) {
      return res.status(404).json({ message: 'Content not found or already deleted.' });
    }
    res.status(200).json({ message: 'Content archived successfully.', content });
  } catch (error) {
    handleError(res, error);
  }
};

// 5. List Content
exports.listContent = async (req, res) => {
  try {
    const {
        page = 1,
        limit = 10,
        status,
        author,
        contentType,
        sortBy = 'createdAt',
        sortOrder = 'desc',
        tag
    } = req.query;

    const query = {};
    if (status) query.status = status;
    if (author) query.author = author;
    if (contentType) query.contentType = contentType;
    if (tag) query.tags = { $in: [tag] };

    const options = {
      page: parseInt(page, 10),
      limit: parseInt(limit, 10),
      sort: { [sortBy]: sortOrder === 'asc' ? 1 : -1 },
      populate: [
        { path: 'author', select: 'name email' },
        { path: 'approver', select: 'name email' }
      ]
    };

    const contents = await Content.find(query)
        .sort(options.sort)
        .skip((options.page - 1) * options.limit)
        .limit(options.limit)
        .populate('author', 'name email')
        .populate('approver', 'name email');

    const totalContents = await Content.countDocuments(query);

    res.status(200).json({
        docs: contents,
        totalDocs: totalContents,
        limit: options.limit,
        page: options.page,
        totalPages: Math.ceil(totalContents / options.limit),
        hasNextPage: options.page * options.limit < totalContents,
        hasPrevPage: options.page > 1,
    });

  } catch (error) {
    handleError(res, error);
  }
};

// 6. Approve Content
exports.approveContent = async (req, res) => {
  try {
    const contentId = req.params.id;
    const approverId = req.user.id;

    const content = await Content.findById(contentId);
    if (!content) {
      return res.status(404).json({ message: 'Content not found.' });
    }

    content.status = 'approved';
    content.approver = approverId;
    // content.approvedAt = Date.now(); // Consider if a dedicated 'approvedAt' field is in the model

    const updatedContent = await content.save();
    res.status(200).json(updatedContent);
  } catch (error) {
    handleError(res, error);
  }
};

// 7. Schedule Content
exports.scheduleContent = async (req, res) => {
  try {
    const contentId = req.params.id;
    const { scheduledAt } = req.body;

    if (!scheduledAt || new Date(scheduledAt) <= Date.now()) {
      return res.status(400).json({ message: 'Scheduled date must be in the future.' });
    }

    const content = await Content.findById(contentId);
    if (!content) {
      return res.status(404).json({ message: 'Content not found.' });
    }
    if (content.status !== 'approved') {
       return res.status(400).json({ message: `Content must be approved before scheduling. Current status: '${content.status}'.`});
    }

    content.scheduledAt = new Date(scheduledAt);
    content.status = 'scheduled';

    const updatedContent = await content.save();
    res.status(200).json(updatedContent);
  } catch (error) {
    handleError(res, error);
  }
};

// 8. Publish Content
exports.publishContent = async (req, res) => {
  try {
    const contentId = req.params.id;

    const content = await Content.findById(contentId);
    if (!content) {
      return res.status(404).json({ message: 'Content not found.' });
    }
    if (!['approved', 'scheduled'].includes(content.status)) {
       return res.status(400).json({ message: `Content in status '${content.status}' cannot be published directly.`});
    }

    content.status = 'published';
    content.publishedAt = Date.now();
    content.scheduledAt = null;

    const updatedContent = await content.save();
    res.status(200).json(updatedContent);
  } catch (error) {
    handleError(res, error);
  }
};

// 9. Revert to a Specific Version
exports.revertToVersion = async (req, res) => {
  try {
    const contentId = req.params.id;
    const versionNumberToRevert = parseInt(req.params.versionNumber, 10);
    const userId = req.user.id;

    const content = await Content.findById(contentId).populate('versionHistory');
    if (!content) {
      return res.status(404).json({ message: 'Content not found.' });
    }

    const versionToRestore = content.versionHistory.find(v => v.version === versionNumberToRevert);
    if (!versionToRestore) {
      return res.status(404).json({ message: `Version ${versionNumberToRevert} not found in history.` });
    }

    // Add current live body to version history before reverting
    content.versionHistory.push({
      body: content.body,
      version: content.version,
      updatedBy: userId,
      updatedAt: Date.now()
    });

    content.body = versionToRestore.body;
    content.version += 1;
    content.updatedAt = Date.now();
    // Optionally change status, e.g., back to 'draft'
    // content.status = 'draft';

    const updatedContent = await content.save();
    res.status(200).json(updatedContent);
  } catch (error) {
    handleError(res, error);
  }
};

// Bulk Update Status
exports.bulkUpdateStatus = async (req, res) => {
  try {
    const { contentIds, status } = req.body; // contentIds is an array of IDs

    if (!contentIds || !Array.isArray(contentIds) || contentIds.length === 0) {
      return res.status(400).json({ message: 'Content IDs must be provided as a non-empty array.' });
    }
    const validStatuses = ['draft', 'pending_approval', 'approved', 'scheduled', 'published', 'archived'];
    if (!status || !validStatuses.includes(status)) {
      return res.status(400).json({ message: `Valid status (${validStatuses.join(', ')}) is required for bulk update.` });
    }

    const updateData = { status };
    if (status === 'approved') {
      updateData.approver = req.user.id; // Assuming approver is the one initiating bulk approval
      // updateData.approvedAt = Date.now(); // If you have this field
    }
    if (status === 'published') {
        updateData.publishedAt = Date.now();
        updateData.scheduledAt = null;
    }
    if (status === 'archived' || status === 'draft') { // Reset publish/schedule dates if moving to these states
        updateData.publishedAt = null;
        updateData.scheduledAt = null;
    }

    const result = await Content.updateMany(
      { _id: { $in: contentIds.map(id => new mongoose.Types.ObjectId(id)) } }, // Ensure IDs are ObjectIds
      { $set: updateData }
    );

    // updateMany in Mongoose 5.x returns { n: matchedCount, nModified: modifiedCount, ok: 1 }
    // In Mongoose 6.x and later, it's { matchedCount, modifiedCount, acknowledged, upsertedId, upsertedCount }
    // Assuming Mongoose 6+ for result structure. If using 5.x, use result.n and result.nModified.
    if (result.modifiedCount === 0 && result.matchedCount > 0) {
        return res.status(200).json({ message: 'No documents were modified; they may already have the target status.', matchedCount: result.matchedCount, modifiedCount: result.modifiedCount });
    }
    if (result.matchedCount === 0) {
        return res.status(404).json({ message: 'No content items found for the provided IDs.', matchedCount: result.matchedCount });
    }

    res.status(200).json({ message: `${result.modifiedCount} content items updated to ${status} successfully.`, matchedCount: result.matchedCount, modifiedCount: result.modifiedCount });
  } catch (error) {
    handleError(res, error);
  }
};

// Bulk Delete (Archive) Content
exports.bulkDeleteContent = async (req, res) => {
  try {
    const { contentIds } = req.body; // contentIds is an array of IDs

    if (!contentIds || !Array.isArray(contentIds) || contentIds.length === 0) {
      return res.status(400).json({ message: 'Content IDs must be provided as a non-empty array.' });
    }

    const result = await Content.updateMany(
      { _id: { $in: contentIds.map(id => new mongoose.Types.ObjectId(id)) } }, // Ensure IDs are ObjectIds
      { $set: { status: 'archived', publishedAt: null, scheduledAt: null } }
    );

    if (result.modifiedCount === 0 && result.matchedCount > 0) {
        return res.status(200).json({ message: 'No documents were modified; they may already be archived.', matchedCount: result.matchedCount, modifiedCount: result.modifiedCount });
    }
    if (result.matchedCount === 0) {
        return res.status(404).json({ message: 'No content items found for the provided IDs.', matchedCount: result.matchedCount});
    }

    res.status(200).json({ message: `${result.modifiedCount} content items archived successfully.`, matchedCount: result.matchedCount, modifiedCount: result.modifiedCount });
  } catch (error) {
    handleError(res, error);
  }
};

// Re-exporting all functions in a standard way
module.exports = {
    createContent: exports.createContent,
    getContentByIdOrSlug: exports.getContentByIdOrSlug,
    updateContent: exports.updateContent,
    deleteContent: exports.deleteContent,
    listContent: exports.listContent,
    approveContent: exports.approveContent,
    scheduleContent: exports.scheduleContent,
    publishContent: exports.publishContent,
    revertToVersion: exports.revertToVersion,
    bulkUpdateStatus: exports.bulkUpdateStatus,
    bulkDeleteContent: exports.bulkDeleteContent,
};
